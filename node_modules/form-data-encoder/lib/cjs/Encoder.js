"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Encoder_instances, _Encoder_CRLF, _Encoder_CRLF_BYTES, _Encoder_CRLF_BYTES_LENGTH, _Encoder_DASHES, _Encoder_encoder, _Encoder_footer, _Encoder_form, _Encoder_getFieldHeader;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Encoder = void 0;
const createBoundary_1 = __importDefault(require("./util/createBoundary"));
const escapeName_1 = __importDefault(require("./util/escapeName"));
const isFormData_1 = __importDefault(require("./util/isFormData"));
const isFile_1 = __importDefault(require("./util/isFile"));
class Encoder {
    /**
     * Creates a multipart/form-data encoder.
     *
     * @param form - FormData object to encode. This object must be a spec-compatible FormData implementation.
     * @param boundary - An optional boundary string that will be used by the encoder. If there's no boundary string is present, Encoder will generate it automatically.
     *
     * @example
     *
     * import {Encoder} from "form-data-encoder"
     * import {FormData} from "formdata-node"
     *
     * const fd = new FormData()
     *
     * fd.set("greeting", "Hello, World!")
     *
     * const encoder = new Encoder(fd)
     */
    constructor(form, boundary = createBoundary_1.default()) {
        _Encoder_instances.add(this);
        _Encoder_CRLF.set(this, void 0);
        _Encoder_CRLF_BYTES.set(this, void 0);
        _Encoder_CRLF_BYTES_LENGTH.set(this, void 0);
        _Encoder_DASHES.set(this, "-".repeat(2)
        /**
         * TextEncoder instance
         */
        );
        /**
         * TextEncoder instance
         */
        _Encoder_encoder.set(this, void 0);
        /**
         * Returns form-data footer bytes
         */
        _Encoder_footer.set(this, void 0);
        /**
         * FormData instance
         */
        _Encoder_form.set(this, void 0);
        if (!isFormData_1.default(form)) {
            throw new TypeError("Expected first argument to be a FormData instance.");
        }
        if (typeof boundary !== "string") {
            throw new TypeError("Expected boundary to be a string.");
        }
        this.boundary = boundary;
        this.contentType = `multipart/form-data; boundary=${this.boundary}`;
        __classPrivateFieldSet(this, _Encoder_encoder, new TextEncoder(), "f");
        __classPrivateFieldSet(this, _Encoder_CRLF, "\r\n", "f");
        __classPrivateFieldSet(this, _Encoder_CRLF_BYTES, __classPrivateFieldGet(this, _Encoder_encoder, "f").encode(__classPrivateFieldGet(this, _Encoder_CRLF, "f")), "f");
        __classPrivateFieldSet(this, _Encoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _Encoder_CRLF_BYTES, "f").byteLength, "f");
        __classPrivateFieldSet(this, _Encoder_form, form, "f");
        __classPrivateFieldSet(this, _Encoder_footer, __classPrivateFieldGet(this, _Encoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _Encoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _Encoder_DASHES, "f")}${__classPrivateFieldGet(this, _Encoder_CRLF, "f").repeat(2)}`), "f");
        this.headers = Object.freeze({
            "Content-Type": this.contentType,
            "Content-Length": this.getContentLength()
        });
    }
    /**
     * Returns form-data content length
     */
    getContentLength() {
        let length = 0;
        for (const [name, value] of __classPrivateFieldGet(this, _Encoder_form, "f")) {
            length += __classPrivateFieldGet(this, _Encoder_instances, "m", _Encoder_getFieldHeader).call(this, name, value).byteLength;
            length += isFile_1.default(value)
                ? value.size
                : __classPrivateFieldGet(this, _Encoder_encoder, "f").encode(String(value)).byteLength;
            length += __classPrivateFieldGet(this, _Encoder_CRLF_BYTES_LENGTH, "f");
        }
        return length + __classPrivateFieldGet(this, _Encoder_footer, "f").byteLength;
    }
    /**
     * Creates an async iterator allowing to perform the encoding by portions.
     *
     * @example
     *
     * import {Readable} from "stream"
     *
     * import {FormData, File, fileFromPath} from "formdata-node"
     * import {Encoder} from "form-data-encoder"
     *
     * import fetch from "node-fetch"
     *
     * const fd = new FormData()
     *
     * fd.set("field", "Just a random string")
     * fd.set("file", new File(["Using files is class amazing"]))
     * fd.set("fileFromPath", await fileFromPath("path/to/a/file.txt"))
     *
     * const encoder = new Encoder(fd)
     *
     * const options = {
     *   method: "post",
     *   headers: encoder.headers,
     *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)
     * }
     *
     * const response = await fetch("https://httpbin.org/post", options)
     *
     * console.log(await response.json())
     */
    async *encode() {
        for (const [name, value] of __classPrivateFieldGet(this, _Encoder_form, "f")) {
            yield __classPrivateFieldGet(this, _Encoder_instances, "m", _Encoder_getFieldHeader).call(this, name, value);
            if (isFile_1.default(value)) {
                yield* value.stream();
            }
            else {
                yield __classPrivateFieldGet(this, _Encoder_encoder, "f").encode(String(value));
            }
            yield __classPrivateFieldGet(this, _Encoder_CRLF_BYTES, "f");
        }
        yield __classPrivateFieldGet(this, _Encoder_footer, "f");
    }
    [(_Encoder_CRLF = new WeakMap(), _Encoder_CRLF_BYTES = new WeakMap(), _Encoder_CRLF_BYTES_LENGTH = new WeakMap(), _Encoder_DASHES = new WeakMap(), _Encoder_encoder = new WeakMap(), _Encoder_footer = new WeakMap(), _Encoder_form = new WeakMap(), _Encoder_instances = new WeakSet(), _Encoder_getFieldHeader = function _Encoder_getFieldHeader(name, value) {
        let header = "";
        header += `${__classPrivateFieldGet(this, _Encoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _Encoder_CRLF, "f")}`;
        header += `Content-Disposition: form-data; name="${escapeName_1.default(name)}"`;
        if (isFile_1.default(value)) {
            header += `; filename="${escapeName_1.default(value.name)}"${__classPrivateFieldGet(this, _Encoder_CRLF, "f")}`;
            header += `Content-Type: ${value.type || "application/octet-stream"}`;
        }
        return __classPrivateFieldGet(this, _Encoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _Encoder_CRLF, "f").repeat(2)}`);
    }, Symbol.asyncIterator)]() {
        return this.encode();
    }
}
exports.Encoder = Encoder;
